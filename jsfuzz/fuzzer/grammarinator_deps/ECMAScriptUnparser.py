# Generated by Grammarinator 17.7

from itertools import chain
from grammarinator.runtime import *

import ECMAScriptUnlexer


class ECMAScriptUnparser(Grammarinator):

    def __init__(self, unlexer):
        super(ECMAScriptUnparser, self).__init__()
        self.unlexer = unlexer
        self.set_options()

    @depthcontrol
    def program(self):
        current = self.create_node(UnparserRule(name='program'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.sourceElements()

        current += self.unlexer.EOF()
        return current
    program.min_depth = 1

    @depthcontrol
    def sourceElements(self):
        current = self.create_node(UnparserRule(name='sourceElements'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.sourceElement()

        return current
    sourceElements.min_depth = 3

    @depthcontrol
    def sourceElement(self):
        current = self.create_node(UnparserRule(name='sourceElement'))
        choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            current += self.statement()
        elif choice == 1:
            current += self.functionDeclaration()
        return current
    sourceElement.min_depth = 2

    @depthcontrol
    def statement(self):
        current = self.create_node(UnparserRule(name='statement'))
        choice = self.choice([0 if [1, 5, 2, 4, 4, 3, 2, 2, 2, 4, 3, 4, 4, 3, 2][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            current += self.block()
        elif choice == 1:
            current += self.variableStatement()
        elif choice == 2:
            current += self.emptyStatement()
        elif choice == 3:
            current += self.expressionStatement()
        elif choice == 4:
            current += self.ifStatement()
        elif choice == 5:
            current += self.iterationStatement()
        elif choice == 6:
            current += self.continueStatement()
        elif choice == 7:
            current += self.breakStatement()
        elif choice == 8:
            current += self.returnStatement()
        elif choice == 9:
            current += self.withStatement()
        elif choice == 10:
            current += self.labelledStatement()
        elif choice == 11:
            current += self.switchStatement()
        elif choice == 12:
            current += self.throwStatement()
        elif choice == 13:
            current += self.tryStatement()
        elif choice == 14:
            current += self.debuggerStatement()
        return current
    statement.min_depth = 1

    @depthcontrol
    def block(self):
        current = self.create_node(UnparserRule(name='block'))
        current += self.create_node(UnlexerRule(src='{'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.statementList()

        current += self.create_node(UnlexerRule(src='}'))
        return current
    block.min_depth = 0

    @depthcontrol
    def statementList(self):
        current = self.create_node(UnparserRule(name='statementList'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.statement()

        return current
    statementList.min_depth = 2

    @depthcontrol
    def variableStatement(self):
        current = self.create_node(UnparserRule(name='variableStatement'))
        current += self.unlexer.Var()
        current += self.variableDeclarationList()
        current += self.eos()
        return current
    variableStatement.min_depth = 4

    @depthcontrol
    def variableDeclarationList(self):
        current = self.create_node(UnparserRule(name='variableDeclarationList'))
        current += self.variableDeclaration()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.variableDeclaration()

        return current
    variableDeclarationList.min_depth = 3

    @depthcontrol
    def variableDeclaration(self):
        current = self.create_node(UnparserRule(name='variableDeclaration'))
        current += self.unlexer.Identifier()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.initialiser()

        return current
    variableDeclaration.min_depth = 2

    @depthcontrol
    def initialiser(self):
        current = self.create_node(UnparserRule(name='initialiser'))
        current += self.create_node(UnlexerRule(src='='))
        current += self.singleExpression()
        return current
    initialiser.min_depth = 2

    @depthcontrol
    def emptyStatement(self):
        current = self.create_node(UnparserRule(name='emptyStatement'))
        current += self.unlexer.SemiColon()
        return current
    emptyStatement.min_depth = 1

    @depthcontrol
    def expressionStatement(self):
        current = self.create_node(UnparserRule(name='expressionStatement'))
        current += self.expressionSequence()
        current += self.eos()
        return current
    expressionStatement.min_depth = 3

    @depthcontrol
    def ifStatement(self):
        current = self.create_node(UnparserRule(name='ifStatement'))
        current += self.unlexer.If()
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.Else()
                current += self.statement()

        return current
    ifStatement.min_depth = 3

    @depthcontrol
    def iterationStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement'))
        choice = self.choice([0 if [3, 3, 2, 4, 3, 3][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            current += self.unlexer.Do()
            current += self.statement()
            current += self.unlexer.While()
            current += self.create_node(UnlexerRule(src='('))
            current += self.expressionSequence()
            current += self.create_node(UnlexerRule(src=')'))
            current += self.eos()
        elif choice == 1:
            current += self.unlexer.While()
            current += self.create_node(UnlexerRule(src='('))
            current += self.expressionSequence()
            current += self.create_node(UnlexerRule(src=')'))
            current += self.statement()
        elif choice == 2:
            current += self.unlexer.For()
            current += self.create_node(UnlexerRule(src='('))
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    current += self.expressionSequence()

            current += self.create_node(UnlexerRule(src=';'))
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    current += self.expressionSequence()

            current += self.create_node(UnlexerRule(src=';'))
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    current += self.expressionSequence()

            current += self.create_node(UnlexerRule(src=')'))
            current += self.statement()
        elif choice == 3:
            current += self.unlexer.For()
            current += self.create_node(UnlexerRule(src='('))
            current += self.unlexer.Var()
            current += self.variableDeclarationList()
            current += self.create_node(UnlexerRule(src=';'))
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    current += self.expressionSequence()

            current += self.create_node(UnlexerRule(src=';'))
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    current += self.expressionSequence()

            current += self.create_node(UnlexerRule(src=')'))
            current += self.statement()
        elif choice == 4:
            current += self.unlexer.For()
            current += self.create_node(UnlexerRule(src='('))
            current += self.singleExpression()
            current += self.unlexer.In()
            current += self.expressionSequence()
            current += self.create_node(UnlexerRule(src=')'))
            current += self.statement()
        elif choice == 5:
            current += self.unlexer.For()
            current += self.create_node(UnlexerRule(src='('))
            current += self.unlexer.Var()
            current += self.variableDeclaration()
            current += self.unlexer.In()
            current += self.expressionSequence()
            current += self.create_node(UnlexerRule(src=')'))
            current += self.statement()
        return current
    iterationStatement.min_depth = 2

    @depthcontrol
    def continueStatement(self):
        current = self.create_node(UnparserRule(name='continueStatement'))
        current += self.unlexer.Continue()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.Identifier()

        current += self.eos()
        return current
    continueStatement.min_depth = 1

    @depthcontrol
    def breakStatement(self):
        current = self.create_node(UnparserRule(name='breakStatement'))
        current += self.unlexer.Break()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.Identifier()

        current += self.eos()
        return current
    breakStatement.min_depth = 1

    @depthcontrol
    def returnStatement(self):
        current = self.create_node(UnparserRule(name='returnStatement'))
        current += self.unlexer.Return()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.expressionSequence()

        current += self.eos()
        return current
    returnStatement.min_depth = 1

    @depthcontrol
    def withStatement(self):
        current = self.create_node(UnparserRule(name='withStatement'))
        current += self.unlexer.With()
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        return current
    withStatement.min_depth = 3

    @depthcontrol
    def switchStatement(self):
        current = self.create_node(UnparserRule(name='switchStatement'))
        current += self.unlexer.Switch()
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.caseBlock()
        return current
    switchStatement.min_depth = 3

    @depthcontrol
    def caseBlock(self):
        current = self.create_node(UnparserRule(name='caseBlock'))
        current += self.create_node(UnlexerRule(src='{'))
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_one():
                current += self.caseClauses()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.defaultClause()
                if self.unlexer.max_depth >= 5:
                    for _ in self.zero_or_one():
                        current += self.caseClauses()


        current += self.create_node(UnlexerRule(src='}'))
        return current
    caseBlock.min_depth = 0

    @depthcontrol
    def caseClauses(self):
        current = self.create_node(UnparserRule(name='caseClauses'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.caseClause()

        return current
    caseClauses.min_depth = 4

    @depthcontrol
    def caseClause(self):
        current = self.create_node(UnparserRule(name='caseClause'))
        current += self.unlexer.Case()
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=':'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.statementList()

        return current
    caseClause.min_depth = 3

    @depthcontrol
    def defaultClause(self):
        current = self.create_node(UnparserRule(name='defaultClause'))
        current += self.unlexer.Default()
        current += self.create_node(UnlexerRule(src=':'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.statementList()

        return current
    defaultClause.min_depth = 1

    @depthcontrol
    def labelledStatement(self):
        current = self.create_node(UnparserRule(name='labelledStatement'))
        current += self.unlexer.Identifier()
        current += self.create_node(UnlexerRule(src=':'))
        current += self.statement()
        return current
    labelledStatement.min_depth = 2

    @depthcontrol
    def throwStatement(self):
        current = self.create_node(UnparserRule(name='throwStatement'))
        current += self.unlexer.Throw()
        current += self.expressionSequence()
        current += self.eos()
        return current
    throwStatement.min_depth = 3

    @depthcontrol
    def tryStatement(self):
        current = self.create_node(UnparserRule(name='tryStatement'))
        choice = self.choice([0 if [3, 2, 3][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            current += self.unlexer.Try()
            current += self.block()
            current += self.catchProduction()
        elif choice == 1:
            current += self.unlexer.Try()
            current += self.block()
            current += self.finallyProduction()
        elif choice == 2:
            current += self.unlexer.Try()
            current += self.block()
            current += self.catchProduction()
            current += self.finallyProduction()
        return current
    tryStatement.min_depth = 2

    @depthcontrol
    def catchProduction(self):
        current = self.create_node(UnparserRule(name='catchProduction'))
        current += self.unlexer.Catch()
        current += self.create_node(UnlexerRule(src='('))
        current += self.unlexer.Identifier()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.block()
        return current
    catchProduction.min_depth = 2

    @depthcontrol
    def finallyProduction(self):
        current = self.create_node(UnparserRule(name='finallyProduction'))
        current += self.unlexer.Finally()
        current += self.block()
        return current
    finallyProduction.min_depth = 1

    @depthcontrol
    def debuggerStatement(self):
        current = self.create_node(UnparserRule(name='debuggerStatement'))
        current += self.unlexer.Debugger()
        current += self.eos()
        return current
    debuggerStatement.min_depth = 1

    @depthcontrol
    def functionDeclaration(self):
        current = self.create_node(UnparserRule(name='functionDeclaration'))
        current += self.unlexer.Function()
        current += self.unlexer.Identifier()
        current += self.create_node(UnlexerRule(src='('))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.formalParameterList()

        current += self.create_node(UnlexerRule(src=')'))
        current += self.create_node(UnlexerRule(src='{'))
        current += self.functionBody()
        current += self.create_node(UnlexerRule(src='}'))
        return current
    functionDeclaration.min_depth = 2

    @depthcontrol
    def formalParameterList(self):
        current = self.create_node(UnparserRule(name='formalParameterList'))
        current += self.unlexer.Identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.unlexer.Identifier()

        return current
    formalParameterList.min_depth = 2

    @depthcontrol
    def functionBody(self):
        current = self.create_node(UnparserRule(name='functionBody'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.sourceElements()

        return current
    functionBody.min_depth = 0

    @depthcontrol
    def arrayLiteral(self):
        current = self.create_node(UnparserRule(name='arrayLiteral'))
        current += self.create_node(UnlexerRule(src='['))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.elementList()

        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src=','))

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.elision()

        current += self.create_node(UnlexerRule(src=']'))
        return current
    arrayLiteral.min_depth = 0

    @depthcontrol
    def elementList(self):
        current = self.create_node(UnparserRule(name='elementList'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.elision()

        current += self.singleExpression()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.elision()

                current += self.singleExpression()

        return current
    elementList.min_depth = 2

    @depthcontrol
    def elision(self):
        current = self.create_node(UnparserRule(name='elision'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src=','))

        return current
    elision.min_depth = 0

    @depthcontrol
    def objectLiteral(self):
        current = self.create_node(UnparserRule(name='objectLiteral'))
        choice = self.choice([0 if [0, 4][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            current += self.create_node(UnlexerRule(src='{'))
            current += self.create_node(UnlexerRule(src='}'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='{'))
            current += self.propertyNameAndValueList()
            if self.unlexer.max_depth >= 0:
                for _ in self.zero_or_one():
                    current += self.create_node(UnlexerRule(src=','))

            current += self.create_node(UnlexerRule(src='}'))
        return current
    objectLiteral.min_depth = 0

    @depthcontrol
    def propertyNameAndValueList(self):
        current = self.create_node(UnparserRule(name='propertyNameAndValueList'))
        current += self.propertyAssignment()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.propertyAssignment()

        return current
    propertyNameAndValueList.min_depth = 3

    @depthcontrol
    def propertyAssignment(self):
        current = self.create_node(UnparserRule(name='propertyAssignment'))
        choice = self.choice([0 if [2, 3, 3][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            current += self.propertyName()
            current += self.create_node(UnlexerRule(src=':'))
            current += self.singleExpression()
        elif choice == 1:
            current += self.getter()
            current += self.create_node(UnlexerRule(src='('))
            current += self.create_node(UnlexerRule(src=')'))
            current += self.create_node(UnlexerRule(src='{'))
            current += self.functionBody()
            current += self.create_node(UnlexerRule(src='}'))
        elif choice == 2:
            current += self.setter()
            current += self.create_node(UnlexerRule(src='('))
            current += self.propertySetParameterList()
            current += self.create_node(UnlexerRule(src=')'))
            current += self.create_node(UnlexerRule(src='{'))
            current += self.functionBody()
            current += self.create_node(UnlexerRule(src='}'))
        return current
    propertyAssignment.min_depth = 2

    @depthcontrol
    def propertyName(self):
        current = self.create_node(UnparserRule(name='propertyName'))
        choice = self.choice([0 if [3, 1, 3][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            current += self.identifierName()
        elif choice == 1:
            current += self.unlexer.StringLiteral()
        elif choice == 2:
            current += self.numericLiteral()
        return current
    propertyName.min_depth = 1

    @depthcontrol
    def propertySetParameterList(self):
        current = self.create_node(UnparserRule(name='propertySetParameterList'))
        current += self.unlexer.Identifier()
        return current
    propertySetParameterList.min_depth = 2

    @depthcontrol
    def arguments(self):
        current = self.create_node(UnparserRule(name='arguments'))
        current += self.create_node(UnlexerRule(src='('))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.argumentList()

        current += self.create_node(UnlexerRule(src=')'))
        return current
    arguments.min_depth = 0

    @depthcontrol
    def argumentList(self):
        current = self.create_node(UnparserRule(name='argumentList'))
        current += self.singleExpression()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.singleExpression()

        return current
    argumentList.min_depth = 2

    @depthcontrol
    def expressionSequence(self):
        current = self.create_node(UnparserRule(name='expressionSequence'))
        current += self.singleExpression()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.singleExpression()

        return current
    expressionSequence.min_depth = 2

    @depthcontrol
    def singleExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression'))
        choice = self.choice([0 if [1, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 3][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            current += self.unlexer.Function()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.Identifier()

            current += self.create_node(UnlexerRule(src='('))
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    current += self.formalParameterList()

            current += self.create_node(UnlexerRule(src=')'))
            current += self.create_node(UnlexerRule(src='{'))
            current += self.functionBody()
            current += self.create_node(UnlexerRule(src='}'))
        elif choice == 1:
            current += self.singleExpression()
            current += self.create_node(UnlexerRule(src='['))
            current += self.expressionSequence()
            current += self.create_node(UnlexerRule(src=']'))
        elif choice == 2:
            current += self.singleExpression()
            current += self.create_node(UnlexerRule(src='.'))
            current += self.identifierName()
        elif choice == 3:
            current += self.singleExpression()
            current += self.arguments()
        elif choice == 4:
            current += self.unlexer.New()
            current += self.singleExpression()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.arguments()

        elif choice == 5:
            current += self.singleExpression()
            current += self.create_node(UnlexerRule(src='++'))
        elif choice == 6:
            current += self.singleExpression()
            current += self.create_node(UnlexerRule(src='--'))
        elif choice == 7:
            current += self.unlexer.Delete()
            current += self.singleExpression()
        elif choice == 8:
            current += self.unlexer.Void()
            current += self.singleExpression()
        elif choice == 9:
            current += self.unlexer.Typeof()
            current += self.singleExpression()
        elif choice == 10:
            current += self.create_node(UnlexerRule(src='++'))
            current += self.singleExpression()
        elif choice == 11:
            current += self.create_node(UnlexerRule(src='--'))
            current += self.singleExpression()
        elif choice == 12:
            current += self.create_node(UnlexerRule(src='+'))
            current += self.singleExpression()
        elif choice == 13:
            current += self.create_node(UnlexerRule(src='-'))
            current += self.singleExpression()
        elif choice == 14:
            current += self.create_node(UnlexerRule(src='~'))
            current += self.singleExpression()
        elif choice == 15:
            current += self.create_node(UnlexerRule(src='!'))
            current += self.singleExpression()
        elif choice == 16:
            current += self.singleExpression()
            choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1])])
            if choice == 0:
                current += self.create_node(UnlexerRule(src='*'))
            elif choice == 1:
                current += self.create_node(UnlexerRule(src='/'))
            elif choice == 2:
                current += self.create_node(UnlexerRule(src='%'))
            current += self.singleExpression()
        elif choice == 17:
            current += self.singleExpression()
            choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                current += self.create_node(UnlexerRule(src='+'))
            elif choice == 1:
                current += self.create_node(UnlexerRule(src='-'))
            current += self.singleExpression()
        elif choice == 18:
            current += self.singleExpression()
            choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1])])
            if choice == 0:
                current += self.create_node(UnlexerRule(src='<<'))
            elif choice == 1:
                current += self.create_node(UnlexerRule(src='>>'))
            elif choice == 2:
                current += self.create_node(UnlexerRule(src='>>>'))
            current += self.singleExpression()
        elif choice == 19:
            current += self.singleExpression()
            choice = self.choice([0 if [0, 0, 0, 0][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
            if choice == 0:
                current += self.create_node(UnlexerRule(src='<'))
            elif choice == 1:
                current += self.create_node(UnlexerRule(src='>'))
            elif choice == 2:
                current += self.create_node(UnlexerRule(src='<='))
            elif choice == 3:
                current += self.create_node(UnlexerRule(src='>='))
            current += self.singleExpression()
        elif choice == 20:
            current += self.singleExpression()
            current += self.unlexer.Instanceof()
            current += self.singleExpression()
        elif choice == 21:
            current += self.singleExpression()
            current += self.unlexer.In()
            current += self.singleExpression()
        elif choice == 22:
            current += self.singleExpression()
            choice = self.choice([0 if [0, 0, 0, 0][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
            if choice == 0:
                current += self.create_node(UnlexerRule(src='=='))
            elif choice == 1:
                current += self.create_node(UnlexerRule(src='!='))
            elif choice == 2:
                current += self.create_node(UnlexerRule(src='==='))
            elif choice == 3:
                current += self.create_node(UnlexerRule(src='!=='))
            current += self.singleExpression()
        elif choice == 23:
            current += self.singleExpression()
            current += self.create_node(UnlexerRule(src='&'))
            current += self.singleExpression()
        elif choice == 24:
            current += self.singleExpression()
            current += self.create_node(UnlexerRule(src='^'))
            current += self.singleExpression()
        elif choice == 25:
            current += self.singleExpression()
            current += self.create_node(UnlexerRule(src='|'))
            current += self.singleExpression()
        elif choice == 26:
            current += self.singleExpression()
            current += self.create_node(UnlexerRule(src='&&'))
            current += self.singleExpression()
        elif choice == 27:
            current += self.singleExpression()
            current += self.create_node(UnlexerRule(src='||'))
            current += self.singleExpression()
        elif choice == 28:
            current += self.singleExpression()
            current += self.create_node(UnlexerRule(src='?'))
            current += self.singleExpression()
            current += self.create_node(UnlexerRule(src=':'))
            current += self.singleExpression()
        elif choice == 29:
            current += self.singleExpression()
            current += self.create_node(UnlexerRule(src='='))
            current += self.singleExpression()
        elif choice == 30:
            current += self.singleExpression()
            current += self.assignmentOperator()
            current += self.singleExpression()
        elif choice == 31:
            current += self.unlexer.This()
        elif choice == 32:
            current += self.unlexer.Identifier()
        elif choice == 33:
            current += self.literal()
        elif choice == 34:
            current += self.arrayLiteral()
        elif choice == 35:
            current += self.objectLiteral()
        elif choice == 36:
            current += self.create_node(UnlexerRule(src='('))
            current += self.expressionSequence()
            current += self.create_node(UnlexerRule(src=')'))
        return current
    singleExpression.min_depth = 1

    @depthcontrol
    def assignmentOperator(self):
        current = self.create_node(UnparserRule(name='assignmentOperator'))
        choice = self.choice([0 if [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            current += self.create_node(UnlexerRule(src='*='))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='/='))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='%='))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='+='))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src='-='))
        elif choice == 5:
            current += self.create_node(UnlexerRule(src='<<='))
        elif choice == 6:
            current += self.create_node(UnlexerRule(src='>>='))
        elif choice == 7:
            current += self.create_node(UnlexerRule(src='>>>='))
        elif choice == 8:
            current += self.create_node(UnlexerRule(src='&='))
        elif choice == 9:
            current += self.create_node(UnlexerRule(src='^='))
        elif choice == 10:
            current += self.create_node(UnlexerRule(src='|='))
        return current
    assignmentOperator.min_depth = 0

    @depthcontrol
    def literal(self):
        current = self.create_node(UnparserRule(name='literal'))
        choice = self.choice([0 if [1, 3][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            choice = self.choice([0 if [1, 1, 1, 3][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
            if choice == 0:
                current += self.unlexer.NullLiteral()
            elif choice == 1:
                current += self.unlexer.BooleanLiteral()
            elif choice == 2:
                current += self.unlexer.StringLiteral()
            elif choice == 3:
                current += self.unlexer.RegularExpressionLiteral()
        elif choice == 1:
            current += self.numericLiteral()
        return current
    literal.min_depth = 1

    @depthcontrol
    def numericLiteral(self):
        current = self.create_node(UnparserRule(name='numericLiteral'))
        choice = self.choice([0 if [2, 2, 2][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            current += self.unlexer.DecimalLiteral()
        elif choice == 1:
            current += self.unlexer.HexIntegerLiteral()
        elif choice == 2:
            current += self.unlexer.OctalIntegerLiteral()
        return current
    numericLiteral.min_depth = 2

    @depthcontrol
    def identifierName(self):
        current = self.create_node(UnparserRule(name='identifierName'))
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            current += self.unlexer.Identifier()
        elif choice == 1:
            current += self.reservedWord()
        return current
    identifierName.min_depth = 2

    @depthcontrol
    def reservedWord(self):
        current = self.create_node(UnparserRule(name='reservedWord'))
        choice = self.choice([0 if [2, 2, 1][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            current += self.keyword()
        elif choice == 1:
            current += self.futureReservedWord()
        elif choice == 2:
            choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                current += self.unlexer.NullLiteral()
            elif choice == 1:
                current += self.unlexer.BooleanLiteral()
        return current
    reservedWord.min_depth = 1

    @depthcontrol
    def keyword(self):
        current = self.create_node(UnparserRule(name='keyword'))
        choice = self.choice([0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            current += self.unlexer.Break()
        elif choice == 1:
            current += self.unlexer.Do()
        elif choice == 2:
            current += self.unlexer.Instanceof()
        elif choice == 3:
            current += self.unlexer.Typeof()
        elif choice == 4:
            current += self.unlexer.Case()
        elif choice == 5:
            current += self.unlexer.Else()
        elif choice == 6:
            current += self.unlexer.New()
        elif choice == 7:
            current += self.unlexer.Var()
        elif choice == 8:
            current += self.unlexer.Catch()
        elif choice == 9:
            current += self.unlexer.Finally()
        elif choice == 10:
            current += self.unlexer.Return()
        elif choice == 11:
            current += self.unlexer.Void()
        elif choice == 12:
            current += self.unlexer.Continue()
        elif choice == 13:
            current += self.unlexer.For()
        elif choice == 14:
            current += self.unlexer.Switch()
        elif choice == 15:
            current += self.unlexer.While()
        elif choice == 16:
            current += self.unlexer.Debugger()
        elif choice == 17:
            current += self.unlexer.Function()
        elif choice == 18:
            current += self.unlexer.This()
        elif choice == 19:
            current += self.unlexer.With()
        elif choice == 20:
            current += self.unlexer.Default()
        elif choice == 21:
            current += self.unlexer.If()
        elif choice == 22:
            current += self.unlexer.Throw()
        elif choice == 23:
            current += self.unlexer.Delete()
        elif choice == 24:
            current += self.unlexer.In()
        elif choice == 25:
            current += self.unlexer.Try()
        return current
    keyword.min_depth = 1

    @depthcontrol
    def futureReservedWord(self):
        current = self.create_node(UnparserRule(name='futureReservedWord'))
        choice = self.choice([0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            current += self.unlexer.Class()
        elif choice == 1:
            current += self.unlexer.Enum()
        elif choice == 2:
            current += self.unlexer.Extends()
        elif choice == 3:
            current += self.unlexer.Super()
        elif choice == 4:
            current += self.unlexer.Const()
        elif choice == 5:
            current += self.unlexer.Export()
        elif choice == 6:
            current += self.unlexer.Import()
        elif choice == 7:
            current += self.unlexer.Implements()
        elif choice == 8:
            current += self.unlexer.Let()
        elif choice == 9:
            current += self.unlexer.Private()
        elif choice == 10:
            current += self.unlexer.Public()
        elif choice == 11:
            current += self.unlexer.Interface()
        elif choice == 12:
            current += self.unlexer.Package()
        elif choice == 13:
            current += self.unlexer.Protected()
        elif choice == 14:
            current += self.unlexer.Static()
        elif choice == 15:
            current += self.unlexer.Yield()
        return current
    futureReservedWord.min_depth = 1

    @depthcontrol
    def getter(self):
        current = self.create_node(UnparserRule(name='getter'))
        current += self.unlexer.Identifier()
        current += self.propertyName()
        return current
    getter.min_depth = 2

    @depthcontrol
    def setter(self):
        current = self.create_node(UnparserRule(name='setter'))
        current += self.unlexer.Identifier()
        current += self.propertyName()
        return current
    setter.min_depth = 2

    @depthcontrol
    def eos(self):
        current = self.create_node(UnparserRule(name='eos'))
        choice = self.choice([0 if [1, 1, 0, 0][i] > self.unlexer.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            current += self.unlexer.SemiColon()
        elif choice == 1:
            current += self.unlexer.EOF()
        elif choice == 2:
            pass
        elif choice == 3:
            pass
        return current
    eos.min_depth = 0

    @depthcontrol
    def eof(self):
        current = self.create_node(UnparserRule(name='eof'))
        current += self.unlexer.EOF()
        return current
    eof.min_depth = 1

    default_rule = program

